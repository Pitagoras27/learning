<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Knowledge bank</title>
    </head>
    <body>
        <script>
            // Ejercicio JS básico
            /*
            imprime en pantalla un string de forma inversa de forma declarativa.
            */

            const reverseString = str => str.split("").reverse().join("");
            console.log(reverseString("hello")); // olleh

            /* Encuentra en el array provisto el elemento que contenga la longitud más amplia*/
            const findLongestWordLength = str => (
                str.split(" ").reduce((acc, curr) => {
                    return Math.max(acc, curr.length)
                }, 0)
            );

            console.log(findLongestWordLength("The quick brown fox jumpedsa over the lazy dog"));

            /*
            comprueba si el valor pasado como parámetro puede clasificarse como booleano primitivo. Retorna true o false.
            */

            const booWho = (bool) => typeof bool === 'boolean';
            console.log(booWho(null));

            /*
            Copia cada elemento del primer array en el segundo, en orden, según lo establezca el índice indicado en el tercer parámetro. Retorna un arreglo como resultado. El array resultante no debe modificar los valores por referencia del arreglo original
            */

            const frankenSplice = (arr1, arr2, n) => {
                const arrCopy = arr2.slice();
                arrCopy.splice(n, 0, ...arr1);
                return arrCopy;
            }

            console.log(frankenSplice([1, 2, 3], [4, 5, 6], 1));
            // frankenSplice([1, 2], ["a", "b"], 1) should return ["a", 1, 2, "b"].
            // frankenSplice(["claw", "tentacle"], ["head", "shoulders", "knees", "toes"], 2) should return ["head", "shoulders", "claw", "tentacle", "knees", "toes"];
            // All elements from the first array should be added to the second array // in their original order.
            // The first array should remain the same after the function runs.
            // The second array should remain the same after the function runs.

            /*
            Elimina cada valor de tipo falsy del conjunto de elementos pasados por parámetro
            */
            const bouncer= arr => arr.filter(Boolean);
            console.log(bouncer([7, "ate", "", false, 9]));

            // bouncer(["a", "b", "c"]) should return ["a", "b", "c"].
            // bouncer([false, null, 0, NaN, undefined, ""]) should return [].
            // bouncer([null, NaN, 1, 2, undefined]) should return [1, 2].

            // ejercicio JS básico "Record Collection" https://www.freecodecamp.org/

            /*
            Modificar los valores y las propiedades del objeto según su id relacionado
            si el valor es una cadena vacía eliminar el nodo relacionado completo
            si la prop es un array pasar el valor al indice final
            si la prop no existe crearla junto con el tipo de dato que contenga, strings o arrays
            eliminar el nodo relacionado si el valor pasado es una cadena vacía.
        */

            function updateRecords(id, prop, value) {
                switch (prop) {
                    case 'artist':
                        if (value !== '') {
                            collection[id][prop] = value
                        }
                        break
                    case 'tracks': // array
                        if (
                            Array.isArray(collection[id][prop]) &&
                            value !== ''
                        ) {
                            collection[id][prop].push(value)
                        } else {
                            collection[id][prop] = [value]
                        }
                        break
                    case 'album':
                        collection[id][prop] = value
                        break
                }

                return collection
            }

            // console.log(updateRecords(5439, "artist", "ABBA"));
            // console.log(updateRecords(5439, "tracks", "Take a Chance on Me"));
            // console.log(updateRecords(2548, "artist", ""));
            // console.log(updateRecords(2468, "tracks", "Free"));
            // console.log(updateRecords(2548, "tracks", ""));
            // console.log(updateRecords(1245, "album", "Riptide"))
        </script>

        <script>
            // ejercicio JS básico "Profile Lookup" https://www.freecodecamp.org/

            /*
            De un objeto contacts comprobar si el parámetro name se corresponde con la propiedad firstName, si
            es así devolver el valor de la propiedad indicada en el segundo parámetro
            En caso de no existir el nombre del contacto devolver el mensaje "No such contact"
            En caso de no existir el nombre de propiedad asignada en el segundo parámetro devolver "No such property"
        */

            function lookUpProfile(name, prop) {
                for (var i = 0; i < contacts.length; i++) {
                    if (contacts[i].firstName === name) {
                        if (contacts[i].hasOwnProperty(prop)) {
                            return contacts[i][prop]
                        } else {
                            return 'No such contact'
                        }
                    }
                }
                return 'No such property'
            }

            // console.log(lookUpProfile("Kristian", "lastName"));
            // console.log(lookUpProfile("Sherlock", "likes"));
            // console.log(lookUpProfile("Harry","likes"));
            // console.log(lookUpProfile("Bob", "number"));
            // console.log(lookUpProfile("Bob", "potato"));
            // console.log(lookUpProfile("Akira", "address"));
        </script>
        <script>
            // ejercicio JS basic algorithm scripting "Confirm the Ending" https://www.freecodecamp.org/

            /*
            Validar con un valor booleano si un string (primer parámetro) finaliza con el string pasado como segundo parámetro
            */
            const confirmEnding = (str, target) => (
                str.slice(str.length - target.length) === target
            );

            // console.log(confirmEnding("Bastian", "n"));
            // console.log(confirmEnding("Congratulation", "on")
            // console.log(confirmEnding("Connor", "n")
            // console.log(confirmEnding("Walking on water and developing software from a specification are easy if both are frozen", "specification")
            // console.log(confirmEnding("He has to give me a new name", "name")
            // console.log(confirmEnding("Open sesame", "same")
            // console.log(confirmEnding("Open sesame", "pen")
            // console.log(confirmEnding("Open sesame", "game")
            // console.log(confirmEnding("If you want to save our world, you must hurry. We dont know how much longer we can withstand the nothing", "mountain")
            // console.log(confirmEnding("Abstraction", "action")

            // Se puede solucionar con el metodo slice.
            // Se puede solucionar con una expresión regular
        </script>

        <script>
            // ejercicio JS basic algorithm scripting "Repeat a String Repeat a String" https://www.freecodecamp.org/
            /*
            Repetir un string (primer parámetro de la función) la cantidad de veces indicada en el segundo parametro y devolverlo
            Si el segundo parámetro es un 0 o un numero negativo devolver una cadena vacía
        */

            const repeatStringNumTimes = (str, num) => {
                let accumulatedStr = '';
                while(num > 0) {
                    accumulatedStr += str;
                    --num
                }
                return accumulatedStr;
            }

            // console.log(repeatStringNumTimes("abc", 3))
            // console.log(repeatStringNumTimes("*", 3))
            // console.log(repeatStringNumTimes("abc", 4))
            // console.log(repeatStringNumTimes("abc", 1))
            // console.log(repeatStringNumTimes("*", 8))
            // console.log(repeatStringNumTimes("abc", -2))

            // Se puede solucionar utilizando un ciclo while
            // Se puede utilizar la recursión
            // Se puede solucionar la función incorporada repeat
        </script>

        <script>
            // ejercicio JS basic algorithm scripting "Truncate a StringPassed" https://www.freecodecamp.org/

            const truncateString = (str, num) => (
                str.length > num ? `${str.slice(0, num)}...` : str
            )

            // console.log(truncateString("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length));
            // console.log(truncateString("A-tisket a-tasket A green and yellow basket", 8))
            // console.log(truncateString("Peter Piper picked a peck of pickled peppers", 11))
            // console.log(truncateString("A-", 1))
            // console.log(truncateString("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length + 2))
            // console.log(truncateString("Absolutely Longer", 2))

            // Mejor utilizar el slice como resultado de un ternario. Sólo espero un 2 tipos de resultado diferente
        </script>

        <script>
            // ejercicio JS basic algorithm scripting "Finders Keepers"
            // Devolver el primero elemento del arreglo cuyo valor divisible entre 2 siempre tenga un residuo de 0. En caso contrario devolver undefined

            const findElement = (arr, func) => arr.find(func)

            // console.log(findElement([1, 2, 3, 4], num => num % 2 === 0));
            // console.log(findElement([1, 3, 5, 8, 9, 10], function(num) { return num % 2 === 0; }))

            // Se puede solucionar empleando el paradigma de programación imperativa utilizando un for
            // Se puede solucionar empreando el paradigma de programación funcional utilizando un find

            function findElement(arr, func) {
                return arr[arr.map(func).indexOf(true)]
            }

            // FORMA BASTANTE COMPLEJA. Utilizando el indice del arreglo pasando la funcion como parametro de un map
            // para que devuelva elementos boleanos con un indexOf obtiene el primero que es true
        </script>

        <script>
            // ejercicio JS basic algorithm scripting  "Title Case a Sentence"
            // Devuelve la cadena provista con la primera letra de cada palabra en mayúscula.
            // Cada una de las palabras deberá estar en minúsculas.

            const titleCase = str => {
                let strToLowerCase = str.toLowerCase().split(" ");
                const result = strToLowerCase.map(element =>
                    element.replace(element.charAt(0), element.charAt(0).toUpperCase())
                );
                return result.join(" ")
            }

            // console.log(titleCase("I'm a little tea pot"));
            // console.log(titleCase("sHoRt AnD sToUt"))
            // console.log(titleCase("HERE IS MY HANDLE HERE IS MY SPOUT"))
        </script>

        <script>
            //  ejercicio JS basic algorithm scripting Slice and Splice
            // The second array should remain the same after the function runs.
        </script>
        <script>
            // Mutations
            // Función que comprueba si todas las letras del string contenido en el primer indice del arreglo pasado por parametro,
            // se encuentran en el string conformado por el segundo indice
            const mutation = arr => {
            const toLower = arr[1].toLowerCase().split("");
            return toLower.every(element =>
                arr[0].toLowerCase().indexOf(element) !== -1
            )}

            console.log(mutation(["hello", "heslo"]));

            // console.log(mutation(["hello", "hey"]))
            // console.log(mutation(["hello", "Hello"]))
            // console.log(mutation(["zyxwvutsrqponmlkjihgfedcba", "qrstu"]))
            // console.log(mutation(["Mary", "Army"])      )
            // console.log(mutation(["Mary", "Aarmy"]))
            // console.log(mutation(["Alien", "line"]))
            // console.log(mutation(["floor", "for"]))
            // console.log(mutation(["hello", "neo"]))
            // console.log(mutation(["voodoo", "no"]))
            // console.log(mutation(["ate", "date"]))
            // console.log(mutation(["Tiger", "Zebra"]))
            // console.log(mutation(["Noel", "Ole"])))
        </script>

        <script>
            // Where do I Belong
            /*
            Inserta el valor pasado como segundo parámetro dentro del array
            pasado como primer parámetro y una vez ordenado de forma ascendente, devuelve el índice del valor pasado insertado en el array.
            */

            const getIndexToIns = (arr, num) => {
                const arrCopy = [...arr, num];
                arrCopy.sort((a, b) => a - b);
                return arrCopy.indexOf(num);
            }

            console.log(getIndexToIns([40, 60], 50));

            // getIndexToIns([10, 20, 30, 40, 50], 35) should return 3.
            // getIndexToIns([10, 20, 30, 40, 50], 30) should return 2.
            // getIndexToIns([40, 60], 50) should return 1.
            // getIndexToIns([3, 10, 5], 3) should return 0.
            // getIndexToIns([5, 3, 20, 3], 5) should return 2.
            // getIndexToIns([2, 20, 10], 19) should return 2.
            // getIndexToIns([2, 5, 10], 15) should return 3.
            // getIndexToIns([], 1) should return 0.

            // LÓGICA DETRÁS DE LA FUNCIÓN DE COMPARACIÓN DE SORT https://www.todojs.com/usar-correctamente-el-metodo-sort/
            /* El método .sort() tiene un único parámetro opcional que permite ayudar a este método para realizar la ordenación del contenido. 
        Esta es la clave para que este método se comporte como nos interesa en cada caso.

        Esta función recibe dos valores a comparar y como resultado debe:

        devolver un valor positivo (1) si e primer valor es superior al segundo
        devolver un valor negativo (-1) si e primer valor es inferior al segundo
        devolver un valor cero (0) si los dos valores son iguales o equivalentes para la ordenación. */
        </script>

        <script>
            // Funcionamiento del stack en JS
        </script>
    </body>
</html>
